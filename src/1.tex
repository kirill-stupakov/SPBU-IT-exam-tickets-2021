\section{История создания методов структуризации данных. Цели и принципы структурной методологии. Сложность, присущая программному обеспечению. Оценки сложности алгоритмов и представления данных.}

\subsection{История}
\textbf{История компьютерной науки} --- это история постепенного повышения уровня абстракции данных, усложнения структур данных, накопления неструктурированных данных и методов выявления из них новых данных и знаний.

\textbf{Стиль} программирования на некотором языке ---  это лежащие в его основе содержательные идеи:
\begin{itemize}
  \item методы для решения некоторого класса задач из определённой предметной области
  \item приёмы для решения задач, объединённых по принципу сходства методов решения
  \item это \underline{НЕ} способ внешнего оформления программ
\end{itemize}

\subsubsection*{}
Сначала этот стиль в основном диктовался:
\begin{itemize}
  \item предоставлениями первых компьютерных теоретиков (состоянием теории алгоритмов и логики)
  \item архитектурой первых вычислительных машин и состоянием техники
\end{itemize}
Хотя компьютеры предназначались для помощи людям, трудности, возникшие при их использовании, были весьма велики, т.к. языки, описывающие и решающие проблемы разработки применительно к инженерным решениям, были заложены в конструкцию ЭВМ. Таким образом, первый стиль программирования был \textbf{императивным}. 

Первые машины обладали \textbf{архитектурой фон Неймана}.
\begin{itemize}
  \item процессор, проводящий основные вычисления
  \item быстрая регистровая память
  \item основная память
  \item внешняя память
  \item программы располагаются во внешней и основной памяти
  \item программы содержат в себе как исполняемые коды, так и данные
  \item инструкции программы также позволяют перемещаться в любое место программы
  \item процессор поочерёдно выполняет инструкции из программы
  \item инструкции вызываются из основной памяти и интерпретируются
  \item данные для инструкций берутся из основной и регистровой памяти
  \item результат выполнения инструкции помещается в основную или регистровую память
  \item при необходимости данные могут быть получены из внешней памяти
\end{itemize}
Мотивация для разделения памяти на основную и регистровую ---  высокая цена качественной памяти

\subsubsection*{}
Следующий этап --- поиск усовершенствованных языков --- результат быстрого роста объёма промышленности:
\begin{itemize}
  \item военные, научные, коммерческие разработки
  \item попытки решить задачи ИИ
\end{itemize}

Первые усовершенствования, оставшиеся в рамках того же стиля программирования --- Fortran, COBOL
\begin{itemize}
  \item укрупнённые инструкции и процедуры
  \item возникло уточнение названия первого стиля программирования --- \textbf{процедурный} или \textbf{процедурно-ориентированный} стиль
  \item данные по-прежнему хранились как числовые коды --- скаляры, векторы, матрицы
  \item появился более высокий уровень абстракции --- символьные данные (строки)
\end{itemize}

\subsubsection*{}
Следующий этап развития --- требования надёжности и эффективности проектирования. Пришло время системных преобразований:
\begin{itemize}
  \item усовершенствование организации и структуризации данных
  \item развитие концепции модульности (инкапсуляция)
  \item появление глобальных переменных
  \item \textbf{структурное программирование}
\end{itemize}

\subsection{Цели и принципы структурной методологии}
\textbf{Структурная методология} --- разработанные строгие правила ведения программных проектов. Её авторы: Дейкстра, Вирт, Хоар и др.

Идеи структурной методологии:
\begin{itemize}
  \item программа --- иерархическая совокупность абстрактных уровней
  \item <<оператор \texttt{goto} нужно считать вредным>>
\end{itemize}

Основное требование --- контроль правильности данных на стадии создания и на стадии выполнения.
\begin{itemize}
  \item дисциплина программирования
  \item читабельности текстов программ \begin{itemize}
    \item оформление
    \item избегание языковых конструкций с неочевидной семантикой
    \item стремление к локализации действий справляемых конструкций и используемых структур данных внутри одной страницы текста кода
  \end{itemize}
  \item эффективность разработки засчёт разбития программы на независимые модули
  \item надёжность программы засчёт возможности сквозного тестирования при хорошей структурированности и читабельности
  \item повышение производительности труба программистов
\end{itemize}

\textbf{Принцип абстракции} --- представление решения без некоторых деталей
\begin{itemize}
  \item позволяет представить весь проект в виде нескольких уровней абстракции
  \item \textbf{стратегии проектирования}
\end{itemize}

\textbf{Принцип формализации} --- строгий методический подход
\begin{itemize}
  \item база для превращения процесса программирования из импровизационной в строго инженерную дисциплину
  \item даёт основания для доказательства правильности программ --- программы изучаются как математические объекты (данные)
\end{itemize}

\textbf{Принцип фрагментации (<<разделяй и властвуй>>)}
\begin{itemize}
  \item простое управление
  \item допускается независимая отладка и тестирование
  \item независимая разработка отдельных частей проекта
\end{itemize}

\textbf{Принцип иерархического управления}
\begin{itemize}
  \item важен не только факт иерархического разбиения, но и его структура
  \item помогает эффективности управления
\end{itemize}

\subsection{Сложность, присущая программному обеспечению}
Главная черта промышленного проектирования --- один разработчик в принципе не может охватить все аспекты такой системы:
\begin{itemize}
  \item предметная область
  \item управление (взаимосвязь модулей)
  \item гибкость, модернизация
  \item эволюция
  \item описание и формализация систем
\end{itemize}

Приёмы, позволяющие решить последнюю задачу --- \textbf{декомпозиция}. Её виды:
\begin{itemize}
  \item алгоритмическая декомпозиция \begin{itemize}
    \item разбиение на процедуры и модули
    \item концентрация внимания на порядке событий
  \end{itemize}
  \item Объектно-ориентированная декомпозиция (по принадлежности к различным абстракциям данных предметной области)
\end{itemize}

Важны оба способа декомпозиции, но лучше начинать проектирование с объектно-ориентированной, так как она
\begin{itemize}
  \item уменьшает размер производимых систем за счёт повторного использования общих механизмов
  \item объектно-ориентированные системы более гибки и проще эволюционируют со временем
\end{itemize}

Дополнительные источники сложности:
\begin{itemize}
  \item научно-практическая проблема, которую следует решить
  \item применяемая технология реализации решения
\end{itemize}